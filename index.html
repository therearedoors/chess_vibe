<!DOCTYPE html>
<html>
<head>
  <title>Chess Vibe</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background: #f0f0f0;
    }
    .chessboard {
      display: grid;
      grid-template-columns: repeat(8, 60px);
      grid-template-rows: repeat(8, 60px);
      border: 2px solid #333;
    }
    .square {
      width: 60px;
      height: 60px;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .light { background-color: #f0d9b5; }
    .dark { background-color: #b58863; }
    .piece { width: 50px; height: 50px; cursor: move; }
    .drop-target { background-color: rgba(0, 255, 0, 0.2); }
  </style>
</head>
<body>
    <div id="menu" style="text-align: center;">
        <h1>Chess Vibe</h1>
        <button onclick="startGame('white')">Play as White</button>
        <button onclick="startGame('black')">Play as Black</button>
      </div>
      <div id="game" style="display: none;"></div> <!-- Board goes here -->
      <script src="rules.js"></script>
      <script>
        const gameState = {
          playerSide: null,
          currentTurn: 'white',
          moveHistory: [], // Track moves for en passant and castling
          gameOver: false
        };
        let draggedPiece = null;
      
        function startGame(side) {
          gameState.playerSide = side;
          document.getElementById('menu').style.display = 'none';
          const gameDiv = document.getElementById('game');
          gameDiv.style.display = 'block';
          renderBoard(gameDiv);
        }
      
        function renderBoard(container) {
    const board = document.createElement('div');
    board.className = 'chessboard';
    container.appendChild(board);

    for (let row = 0; row < 8; row++) {
      for (let col = 0; col < 8; col++) {
        const square = document.createElement('div');
        square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
        square.dataset.row = row;
        square.dataset.col = col;

        const piece = getPiece(row, col);
        if (piece) {
          const img = document.createElement('img');
          img.src = piece;
          img.className = 'piece';
          img.draggable = true;
          img.dataset.type = getPieceType(piece);
          img.dataset.color = getPieceColor(piece);
          img.ondragstart = (e) => {
            if (!gameState.gameOver && gameState.playerSide === gameState.currentTurn && 
                img.dataset.color === gameState.playerSide) {
              draggedPiece = img;
              e.dataTransfer.setData('text/plain', `${row},${col}`);
            }
          };
          square.appendChild(img);
        }

        square.ondragover = (e) => e.preventDefault();
        square.ondragenter = () => {
          if (isValidMove(draggedPiece, square)) {
            square.classList.add('drop-target');
          }
        };
        square.ondragleave = () => square.classList.remove('drop-target');
        square.ondrop = (e) => {
          e.preventDefault();
          square.classList.remove('drop-target');
          if (draggedPiece && isValidMove(draggedPiece, square)) {
            const fromRow = parseInt(draggedPiece.parentElement.dataset.row);
            const fromCol = parseInt(draggedPiece.parentElement.dataset.col);
            const toRow = parseInt(square.dataset.row);
            const toCol = parseInt(square.dataset.col);
            let capturedPiece = null;
            if (square.querySelector('.piece')) {
              capturedPiece = square.querySelector('.piece');
              square.removeChild(capturedPiece);
            } else if (draggedPiece.dataset.type === 'pawn' && Math.abs(fromCol - toCol) === 1) {
              // En passant capture
              const enPassantRow = gameState.currentTurn === 'white' ? toRow + 1 : toRow - 1;
              const enPassantSquare = document.querySelector(`.square[data-row="${enPassantRow}"][data-col="${toCol}"]`);
              if (enPassantSquare && enPassantSquare.querySelector('.piece')) {
                capturedPiece = enPassantSquare.querySelector('.piece');
                enPassantSquare.removeChild(capturedPiece);
              }
            }
            square.appendChild(draggedPiece);
            gameState.moveHistory.push({ fromRow, fromCol, toRow, toCol, piece: draggedPiece.dataset.type });
            gameState.currentTurn = gameState.currentTurn === 'white' ? 'black' : 'white';
            draggedPiece = null;
            if (isInCheckmate(gameState.currentTurn)) {
              alert(`${gameState.currentTurn} is in checkmate! Game over.`);
              gameState.gameOver = true;
            } else if (isInCheck(gameState.currentTurn)) {
              console.log(`${gameState.currentTurn} is in check!`);
            }
            if (!gameState.gameOver && gameState.playerSide !== gameState.currentTurn) {
              setTimeout(makeAIMove, 500);
            }
          }
        };

        board.appendChild(square);
      }
    }
  }
      
  function makeAIMove() {
    const aiColor = gameState.playerSide === 'white' ? 'black' : 'white';
    const pieces = Array.from(document.querySelectorAll(`.piece[data-color="${aiColor}"]`));
    let validMoves = [];

    // If AI is in check, filter moves that break it
    const inCheck = isInCheck(aiColor);
    if (inCheck && isInCheckmate(aiColor)) {
      alert(`${aiColor} is in checkmate! ${gameState.playerSide} wins!`);
      gameState.gameOver = true;
      return;
    }

    for (const piece of pieces) {
      const fromRow = parseInt(piece.parentElement.dataset.row);
      const fromCol = parseInt(piece.parentElement.dataset.col);
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const target = document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
          if (isValidMove(piece, target)) {
            // Simulate the move
            const originalSquare = piece.parentElement;
            const targetPiece = target.querySelector('.piece');
            let rookMoved = false;
            let rookSquare = null, rook = null, newRookSquare = null;

            if (piece.dataset.type === 'king' && Math.abs(col - fromCol) === 2) {
              const rookCol = col > fromCol ? 7 : 0;
              rookSquare = document.querySelector(`.square[data-row="${fromRow}"][data-col="${rookCol}"]`);
              rook = rookSquare.querySelector('.piece');
              const newRookCol = col > fromCol ? 5 : 3;
              newRookSquare = document.querySelector(`.square[data-row="${fromRow}"][data-col="${newRookCol}"]`);
              newRookSquare.appendChild(rook);
              rookMoved = true;
            }

            if (targetPiece) target.removeChild(targetPiece);
            else if (piece.dataset.type === 'pawn' && Math.abs(fromCol - col) === 1) {
              const enPassantRow = aiColor === 'white' ? row + 1 : row - 1;
              const enPassantSquare = document.querySelector(`.square[data-row="${enPassantRow}"][data-col="${col}"]`);
              if (enPassantSquare && enPassantSquare.querySelector('.piece')) {
                enPassantSquare.removeChild(enPassantSquare.querySelector('.piece'));
              }
            }
            target.appendChild(piece);

            // Check if this move leaves/breaks check
            const stillInCheck = isInCheck(aiColor);
            const isLegalMove = inCheck ? !stillInCheck : !stillInCheck;

            // Undo the move
            originalSquare.appendChild(piece);
            if (targetPiece) target.appendChild(targetPiece);
            if (rookMoved) rookSquare.appendChild(rook);

            if (isLegalMove) {
              validMoves.push({ piece, fromRow, fromCol, toRow: row, toCol: col, target });
            }
          }
        }
      }
    }

    if (validMoves.length > 0) {
      const move = validMoves[Math.floor(Math.random() * validMoves.length)];
      if (move.piece.dataset.type === 'king' && Math.abs(move.toCol - move.fromCol) === 2) {
        const rookCol = move.toCol > move.fromCol ? 7 : 0;
        const rookSquare = document.querySelector(`.square[data-row="${move.fromRow}"][data-col="${rookCol}"]`);
        const rook = rookSquare.querySelector('.piece');
        const newRookCol = move.toCol > move.fromCol ? 5 : 3;
        const newRookSquare = document.querySelector(`.square[data-row="${move.fromRow}"][data-col="${newRookCol}"]`);
        newRookSquare.appendChild(rook);
        move.target.appendChild(move.piece);
      } else {
        if (move.target.querySelector('.piece')) {
          move.target.removeChild(move.target.querySelector('.piece'));
        } else if (move.piece.dataset.type === 'pawn' && Math.abs(move.fromCol - move.toCol) === 1) {
          const enPassantRow = aiColor === 'white' ? move.toRow + 1 : move.toRow - 1;
          const enPassantSquare = document.querySelector(`.square[data-row="${enPassantRow}"][data-col="${move.toCol}"]`);
          if (enPassantSquare && enPassantSquare.querySelector('.piece')) {
            enPassantSquare.removeChild(enPassantSquare.querySelector('.piece'));
          }
        }
        move.target.appendChild(move.piece);
      }
      gameState.moveHistory.push({ fromRow: move.fromRow, fromCol: move.fromCol, toRow: move.toRow, toCol: move.toCol, piece: move.piece.dataset.type });
      gameState.currentTurn = gameState.playerSide;

      const checkedColor = gameState.currentTurn;
      if (isInCheckmate(checkedColor)) {
        alert(`${checkedColor} is in checkmate! ${aiColor} wins!`);
        gameState.gameOver = true;
      } else if (isInCheck(checkedColor)) {
        alert(`${checkedColor} is in check!`);
      }
    } else if (inCheck) {
      alert(`${aiColor} is in checkmate! ${gameState.playerSide} wins!`);
      gameState.gameOver = true;
    }
  }
      
        function getPiece(row, col) {
          const pieces = {
            0: ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'],
            1: 'pawn',
            6: 'pawn',
            7: ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook']
          };
          if (row in pieces) {
            const color = row < 2 ? 'black' : 'white';
            const piece = row === 1 || row === 6 ? pieces[row] : pieces[row][col];
            return `./chess-assets/${color}/SVG_icons/${piece}.svg`;
          }
          return null;
        }
      
        function getPieceType(src) {
          return src.split('/').pop().replace('.svg', '');
        }
      
        function getPieceColor(src) {
          return src.includes('black') ? 'black' : 'white';
        }

  

      </script>
</body>
</html>